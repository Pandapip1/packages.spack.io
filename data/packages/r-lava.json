{
    "name": "r-lava",
    "aliases": [],
    "versions": [
        {
            "name": "1.7.2.1",
            "sha256": "d42b1f5c7e4e76718e4f014c44608295f82b5de0eb25ce8e9b35c40c7839ef2e"
        },
        {
            "name": "1.7.0",
            "sha256": "3078da69f3828812bcd093acc2d1cd2c8cbc8480d81da222ae49a55bcb2e5e24"
        },
        {
            "name": "1.6.10",
            "sha256": "7a88f8a885872e2abb3011c446e9e1c4884cd4dbe6ab4cfe9207538e5560232e"
        },
        {
            "name": "1.6.8.1",
            "sha256": "6d243fc86c67c78ff4763502d84ff2f0889c2e55d1a59afefb7a762887473ffa"
        },
        {
            "name": "1.6.6",
            "sha256": "7abc84dd99cce450a45ac4f232812cde3a322e432da3472f43b057fb5c59ca59"
        },
        {
            "name": "1.6.4",
            "sha256": "41c6eeb96eaef9e1bfb04b31f7203e250a5ea7e7860be4d95f7f96f2a8644718"
        },
        {
            "name": "1.4.7",
            "sha256": "d5cbd4835a94855478efb93051eece965db116ead203f4dd4e09d9a12d52f4bf"
        }
    ],
    "latest_version": "1.7.2.1",
    "build_system": "RPackage",
    "conflicts": [],
    "variants": [
        {
            "name": "build_system",
            "default": "generic",
            "description": "Build systems supported by the package"
        }
    ],
    "homepage": "https://cloud.r-project.org/package=lava",
    "maintainers": [],
    "patches": [],
    "resources": [],
    "description": "Latent Variable Models. A general implementation of Structural Equation\nModels with latent variables (MLE, 2SLS, and composite likelihood\nestimators) with both continuous, censored, and ordinal outcomes (Holst\nand Budtz-Joergensen (2013) <doi:10.1007/s00180-012-0344-y>). Mixture\nlatent variable models and non-linear latent variable models (Holst and\nBudtz-Joergensen (2019) <doi:10.1093/biostatistics/kxy082>). The package\nalso provides methods for graph exploration (d-separation, back-door\ncriterion), simulation of general non-linear latent variable models, and\nestimation of influence functions for a broad range of statistical\nmodels.\n",
    "dependencies": [
        {
            "name": "r",
            "description": "R is 'GNU S', a freely available language and environment for\nstatistical computing and graphics which provides a wide variety of\nstatistical and graphical techniques: linear and nonlinear modelling,\nstatistical tests, time series analysis, classification, clustering,\netc. Please consult the R project homepage for further information."
        },
        {
            "name": "r-future-apply",
            "description": "Apply Function to Elements in Parallel using Futures. Implementations of\napply(), by(), eapply(), lapply(), Map(), mapply(), replicate(),\nsapply(), tapply(), and vapply() that can be resolved using any future-\nsupported backend, e.g. parallel on the local machine or distributed on\na compute cluster. These future_*apply() functions come with the same\npros and cons as the corresponding base-R *apply() functions but with\nthe additional feature of being able to be processed via the future\nframework."
        },
        {
            "name": "r-progressr",
            "description": "An Inclusive, Unifying API for Progress Updates. A minimal, unifying API\nfor scripts and packages to report progress updates from anywhere\nincluding when using parallel processing. The package is designed such\nthat the developer can to focus on what progress should be reported on\nwithout having to worry about how to present it. The end user has full\ncontrol of how, where, and when to render these progress updates, e.g.\nin the terminal using utils::txtProgressBar() or\nprogress::progress_bar(), in a graphical user interface using\nutils::winProgressBar(), tcltk::tkProgressBar() or\nshiny::withProgress(), via the speakers using beep::beepr(), or on a\nfile system via the size of a file. Anyone can add additional,\ncustomized, progression handlers. The 'progressr' package uses R's\ncondition framework for signaling progress updated. Because of this,\nprogress can be reported from almost anywhere in R, e.g. from classical\nfor and while loops, from map-reduce API:s like the lapply() family of\nfunctions, 'purrr', 'plyr', and 'foreach'. It will also work with\nparallel processing via the 'future' framework, e.g.\nfuture.apply::future_lapply(), furrr::future_map(), and 'foreach' with\n'doFuture'. The package is compatible with Shiny applications."
        },
        {
            "name": "r-numderiv",
            "description": "Accurate Numerical Derivatives. Methods for calculating (usually)\naccurate numerical first and second order derivatives. Accurate\ncalculations are done using 'Richardson\"s' extrapolation or, when\napplicable, a complex step derivative is available. A simple difference\nmethod is also provided. Simple difference is (usually) less accurate\nbut is much quicker than 'Richardson\"s' extrapolation and provides a\nuseful cross-check. Methods are provided for real scalar and vector\nvalued functions."
        },
        {
            "name": "r-survival",
            "description": "Survival Analysis. Contains the core survival analysis routines,\nincluding definition of Surv objects, Kaplan-Meier and Aalen-Johansen\n(multi-state) curves, Cox models, and parametric accelerated failure\ntime models."
        },
        {
            "name": "r-squarem",
            "description": "Squared Extrapolation Methods for Accelerating EM-Like Monotone\nAlgorithms. Algorithms for accelerating the convergence of slow,\nmonotone sequences from smooth, contraction mapping such as the EM\nalgorithm. It can be used to accelerate any smooth, linearly convergent\nacceleration scheme. A tutorial style introduction to this package is\navailable in a vignette on the CRAN download page or, when the package\nis loaded in an R session, with vignette(\"SQUAREM\"). Refer to the J Stat\nSoftware article: <doi:10.18637/jss.v092.i07>."
        }
    ],
    "dependent_to": [
        {
            "name": "r-prodlim",
            "description": "Product-Limit Estimation for Censored Event History Analysis. Product-\nLimit Estimation for Censored Event History Analysis. Fast and user\nfriendly implementation of nonparametric estimators for censored event\nhistory (survival) analysis. Kaplan-Meier and Aalen-Johansen method."
        }
    ]
}